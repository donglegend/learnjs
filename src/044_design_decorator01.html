<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>044_design_decorator01</title>
    <!-- 引入的核心js公共文件 -->
    <script type="text/javascript" src="../commons/CommonUtil.js"></script>
    <script type="text/javascript">
        //装饰者模式 就是在不改变原有对象的基础上 去扩展一些想要的方法或需求
        //实现同样接口
        //需要有子类
        /*
        var CarInterface = new CT.Interface('CarInterface',['getPrice','assemble']);
        var Car = function(car){
            //在父类里写 就是为了让子类继承(让子类多一个父类的引用)
            this.car = car ;
            //检测接口
            CT.Interface.ensureImplements(this,CarInterface);
        };
        Car.prototype = {
            constructor : Car ,
            getPrice : function(){
                return 200000;
            },
            assemble : function(){
                document.write('组装汽车...');
            }
        };

        //新的需求: Light  icebox .....  子类...
        //实例化对象
        var LightDecorator = function(car){  //原始对象
            //借用构造函数继承
            LightDecorator.superClass.constructor.call(this,car);

            //继承父类的
            //this.car = car ;
            //CT.Interface.ensureImplements(this,CarInterface);
        };

        CT.extend(LightDecorator,Car);//原型继承

        LightDecorator.prototype = {
            constructor : LightDecorator,
            //为什么使用同样的接口
            getPrice : function(){
                return this.car.getPrice() + 10000;
            },
            assemble : function(){
                document.write('组装车灯...');
            }
        };

        //新的需求
        var IceBoxDecorator = function(car){
            IceBoxDecorator.superClass.constructor.call(this,car);
        };
        CT.extend(IceBoxDecorator,Car);//原型继承

        IceBoxDecorator.prototype = {
            constructor : IceBoxDecorator,
            getPrice : function(){
                return this.car.getPrice() + 20000;
            },
            assemble : function(){
                document.write('组装车载冰箱...');
            }
        };



        var car = new Car();
        alert(car.getPrice());
        car.assemble();
        
        //此处后期可删除 不改变原始对象  没有耦合关系
        car = new LightDecorator(car);
        alert(car.getPrice());
        car.assemble();

        car = new IceBoxDecorator(car);
        alert(car.getPrice());
        car.assemble();
        */
       
        //装饰者不仅可以用在类上 还可以用在函数上
        //返回一个当前时间的字符串表示
        function getDate(){
            return (new Date()).toString();
        };
        //包装函数(装饰者函数) 改大写
        function upperCaseDecorator(fn){
            return function(){
                return fn.apply(this,arguments).toUpperCase();
            }
        };
        alert(getDate());

        var getDecoratorDate = upperCaseDecorator(getDate);
        alert(getDecoratorDate());
        

    </script>
</head>
<body>
    
</body>
</html>